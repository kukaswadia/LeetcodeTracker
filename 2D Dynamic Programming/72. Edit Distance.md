```python
            if i == len(word1):
                return len(word2) - j
            if j == len(word2):
                return len(word1) - i
```

Those are the recursion base cases in the top‑down edit distance:

- When index i has reached the length of the first word, all its characters are already processed. The only way to finish is to insert every remaining character from the second word (from position j onward). Cost = remaining length of second word.
- When index j has reached the length of the second word, all its characters are matched already. The only way to finish is to delete every remaining character left in the first word (from position i onward). Cost = remaining length of first word.

They terminate recursion by returning the exact number of unavoidable single‑character operations left.

```python
            if word1[i] == word2[j]:
                memo[(i, j)] = helper(i + 1, j + 1)
```
We have a character match (same letters at positions i and j).  
Logic:

- Since they are equal, no edit operation (cost 0) is needed at this step.
- We advance both indices to the next characters (i\+1, j\+1).
- We memoize the result for state (i, j) so future calls reuse it instead of recomputing.

```python
            else:
                replace = 1 + helper(i + 1, j + 1)
                insert = 1 + helper(i, j + 1)
                delete = 1 + helper(i + 1, j)
                memo[(i, j)] = min(replace, insert, delete)
```

You are at a mismatch (word1\[i] != word2\[j]). You must choose exactly one edit operation to apply now. The decision of which index(es) to advance is dictated by the meaning of each edit:

- Replace: You substitute word1\[i] with word2\[j]. Both characters are consumed, so advance i and j. Cost = 1 (the replace you just did) + optimal future cost.
- Insert (into word1): You insert word2\[j] before word1\[i]. The word2 character is now matched by the inserted one, so advance j only; i stays because word1\[i] still needs to be matched. Cost = 1 + future.
- Delete (from word1): You remove word1\[i]. That character is gone, so advance i only; j stays because word2\[j] still needs a counterpart. Cost = 1 + future.

Why add 1 first: the cost model counts each single edit operation as 1. The recursive call returns the minimal number of edits needed after that operation. So each expression is:
cost_now (1 for the chosen edit) + minimal_remaining_edits (from the advanced indices).

Then you take the minimum of the three to pick the cheapest path.

If the characters match you advance both with no added cost because no edit was performed (cost 0).
















